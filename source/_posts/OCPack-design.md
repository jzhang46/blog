---
title: OCPack技术方案总结
date: 2018-12-19 19:35:58
tags:
---

# OCPack技术方案总结

## I. 简介
OCPack是一种iOS动态化方案，用户可以用OC编写待动态化的功能逻辑（.m），然后通过OCPack提供的工具链生成patch文件（.bin)。客户端则内置了一个基于Native环境的的虚拟栈机，它可以动态加载并执行存储在客户端的patch文件中的方法。patch文件可根据业务需要随时下载、更新并由虚拟机重新加载、运行。  

此方案的主要优点：  

1.开发效率  
可以使开发者像写普通功能代码一样，使用熟悉的Xcode IDE和Objective-C语言进行开发、调试，在开发完成后使用工具链即可方便地生成patch文件，提高开发patch的效率。

2.语法覆盖  
考虑到使用者的方便性和开发周期的平衡，目前OCPack的实现覆盖了c语言的基本语法和Objective-C中比较常用的语法，保证开发者在使用中大部分常用的写法都能直接支持，而部分不能支持的语法也有相应的替代实现方式。

3.问题定位
* 对于暂不支持的语法，OCPack的工具链能够明确地给出错误原因提示及错误代码位置，方便定位开发中遇到的问题。  
* 上线后也可以调用相应接口获取虚拟机在各线程的调用栈信息，结合编译过程中生成的符号文件，开发就能够准确定位到当时虚拟机调用到的源文件代码行数，方便定位、解决线上问题。符号解析工具也包含在工具链中。

4.性能  
由于是基于Native环境，且自定义的栈机指令集意义明确、设计精简，并且大部分与Native环境之间的交互都是直接操作内存地址，省去了像JSPatch一样频繁字符串解析及Box/Unbox的开销。其中OC桥接调用效率近似原生。

5.内存及稳定性  
* JS的GC的内存管理机制会导致内存不能及时释放，而如果强行释放掉JSContext会导致线上出现一些诡异的崩溃，难以定位和解决。
* 此方案的内存管理完全由用户代码控制（MRC），能够与客户端的ARC/MRC内存管理机制正确配合，消除了GC时机不可控的问题。
* 而且结合xxx本身的特点，将主要内存都放到mmap中，尽量不占用xxx的内存配额，提高xxx的稳定性。

<!-- more -->

## II. 技术方案
OCPack使用clang分析目标Objective-C代码的语法树，通过自定义ASTFrontendAction来遍历语法树，生成自定义指令集的汇编程序。在客户端，由自研的虚拟栈机来解释执行汇编程序中的二进制指令。

生成patch文件的基本数据流程是：  
* OC源码会首先通过OCPack编译工具转换为自定义指令集的汇编程序（.s）。此过程主要是通过解析LLVM生成的OC代码语法树（AST）实现的。  
* 汇编程序则通过一个assemble工具（smc）转换为二进制的patch文件（.bin）。  
我们自定义的栈机汇编指令主要有67条，除基本指令以外，主要是依据语法树结点类型设计。  

在运行时，客户端内置的虚拟栈机能够根据用户需求加载指定的patch文件，然后就可以执行其中任意方法了。  

以下分模块来介绍主要技术点：

### Compiler：Objective-C程序(.m) -> 语法树 -> 汇编程序(.s)

#### 1. 独立的编译程序
主要使用clang的libTooling接口，实现了AST FrontendAction，通过实现自定义的ASTConsumer递归遍历语法树，对不同的节点类型作相应处理，生成可执行的汇编指令程序。
* 编译选项  
要调用clang的模块为目标OC文件(.m)生成语法树，需要先提供编译此.m所需的编译选项。对于集成方来说，目标文件可能需要依赖很多相关的.h或有其他编译开关，为了方便集成方得到完整的编译选项列表，我们制作了相应的工具，可以方便地从集成方工程的编译日志中得到目标文件所需的编译选项的完整列表。

* 编译错误和警告  
OCPack支持Objective-C语言中常用的语法类型，对于不支持的语法，在编译期间会生成相应的日志文件，具体标明了错误类型和错误位置 ，方便开发定位问题。  

**注**：为了进一步提高开发效率，OCPack还实现了一个独立的clang plugin，可以通过给工程添加一个.xcconfig文件（替换默认的clang），实现在Xcode中显示相关的编译错误，并能一键生成.bin，省去了获取编译选项和手工查看错误日志的步骤，简化了开发流程。

#### 2. 栈机汇编指令集
为了连接包含有Objective-C代码逻辑的语法树和客户端运行的虚拟机，OCPack需要定义一套比较完整的汇编指令集。该指令集应该满足以下两个条件：
* 提供足够的功能支持，用以实现预定义的Objective-C语法范围。具体地，对于指定的语法树节点类型集合，能够通过编译逻辑生成相应的汇编指令组合，等价地完成原Objective-C代码所要实现的逻辑功能。
* 尽量减少指令集的复杂性：一方面应尽量减少指令的条数，以降低虚拟机实现的复杂性；另一方面应尽量降低单条指令本身的语义复杂性，每条指令应完成明确而有限的功能。

以下简要介绍几个比较典型的指令的设计方案：

##### 2.1 push和pop指令
栈机中最基本的部件是操作栈，用于存放正在进行中的操作数和操作结果。如：要计算1+2，栈机需要执行类似以下指令：
```objc
    push instant 1
    push instant 2
    add
```
先将两个操作数`1`和`2`依次push进操作栈，再执行add操作。add操作负责先pop对应的操作数，经过加法计算后再将结果push进栈。以上指令执行完后，操作栈顶存放的就是操作结果`3`。  
但只有操作栈是不够的，程序逻辑的复杂性要求像局部变量、方法参数等数据拥有确定不变的内存地址，因此OCPack将局部变量、静态变量、常量、指针、立即数等分别对应一个段，每种类型的变量对应于所属段中的一个index。  

* 段：用于存放各种非临时数据（可取到地址的数据），这些数据又分线程相关与线程无关，其中：  
    线程相关的数据段主要包括：  
    ```objc
            local    //局部变量
            arg      //方法实参
            this     //存放self（用于super的实现）
            that     //用于实现struct的成员变量
            pointer  //用于辅助实现this, that 
            //注: 线程相关的段数据存放在thread_context(线程局部存储)中，只对本线程可见
    ```  
    
    线程无关的数据段主要包括：  
    ```objc
            const    //常量字符串
            static   //静态变量
            instant  //立即数
            //注：线程无关的段数据存放在machine中，各线程都可见
    ```  
    
在对语法树进行遍历的过程中，OCPack编译器会维护一个符号表，对每个变量声明(VarDecl)建立相应的符号表项，存放其段名和index。  
对语法树中的变量引用(VarDeclRef结点)，OCPack编译器会找到其相应的VarDecl的符号表项，生成相应的push、pop指令。  
push和pop指令的参数就是段名和index：  
* **push** `segment` `index` —— 将segment段中的index处数据push到操作栈顶
* **pop** `segment` `index` —— 将操作栈顶的数据pop到segment段中的index处

##### 2.2 prolog指令
* prolog指令是每个虚拟机中方法的第一条指令，它会根据其指令参数为当前方法栈帧中的local段开辟相应大小的段空间，并记录当前栈帧的返回地址，然后计算并记录参数列表(arg段)起始地址，再将调用者的栈顶指针指向参数表之前，最后切换到被调用者的栈帧。
* 格式：**prolog** `arg_size` `local_size`  
    * 其中arg_size表示所有参数的总长度，用于计算参数列表的起始地址  
    * local_size表示局部变量段的长度

方法调用和传参这块的设计需要一些特别的考虑，主要需要满足几个要求：
- 调用者只需将参数和返回值按要求push到操作栈上，然后直接跳转到被调方法的起始地址，程序就可顺利执行，调用方不应承担其他不必要的责任
- 根据栈机的一般调用逻辑，被调函数返回时，刚才push进来的参数和返回值应该已由被调者pop，此时栈顶应该只有返回值，栈顶以下应该是跟这次调用无关的其他数据
- 被调方需要知道参数和返回地址的具体位置，参数需要有固定地址，支持随机访问，不能是只靠pop得到的暂存值
- 局部变量也需要随机访问，其大小需要在函数执行一开始就分配好

为了满足这些需求，OCPack中设计了prolog这一指令：
- 在每个方法头部加此指令，调用者一跳到当前方法就执行此指令，相关设置都在此指令中执行，尽量减少对调用者的要求。
- 根据约定，执行到prolog时，栈顶存放的是返回地址，栈顶以下是倒排的参数表，prolog指令先pop返回地址并保存下来，然后将调用者的栈桢的sp往回调整参数表的长度（此长度作为指令参数由编译时确定，调用者无需通过栈来传递此信息），也即指向第一个参数的位置。注意此时还没有生成被调用者的栈桢，所有的操作都还在调用者的栈桢上下文内。这样就能够保证被调者返回时调用者的sp是在合适的位置，到时候直接push返回值就可以。
- 此时prolog根据返回地址及调用者的栈桢信息生成新栈桢，新栈帧中建立的arg段直接指向参数表的起始位置，之后访问参数即可使用push arg i或pop arg i等指令。
- 同时，局部变量的local段也需要建立，其大小也由编译时确定，即是prolog指令的local_size参数，在建好栈桢并切换当前栈帧后，即完成了方法调用的过渡阶段，程序流程便可继续进行。

##### 2.3 ret指令
* ret指令是虚拟机中方法的最后一条指令，与prolog相对应，用于回退栈帧（unwind frame），并将返回值数据由被调方的栈顶拷贝到unwind以后调用方的操作栈顶，以实现调用完成后返回值位于当前栈顶的调用约定。
* 格式：**ret** `retSize` 

此处有一次数据拷贝，拷贝大小即为返回值的大小。为尽量减少对调用者的影响，在编译期给ret方法增加retSize参数，以便在执行ret的时候就能完成数据拷贝，栈帧回退到调用者后，调用者可以预期返回值就在自己操作栈的栈顶，后续逻辑不受当前栈顶值是由方法调用返回还是自行push得到的影响，逻辑较清晰。

##### 2.4 跳转指令
为了实现条件判断if/else和for循环等流程控制语法，OCPack指令集定义了`jmp`和`jmp_if`指令，根据语法树中对应类型的节点具体情况，生成相应的跳转指令和跳转label。这些文本跳转label会被存储在.s文件中，然后在下一阶段（Assembler将.s转换为.bin时）被替换成相应的偏移地址。

##### 2.5 switch指令
###### 1) switch跳转表
switch需要运行时决定跳到哪个case label对应的地址，只用`jmp_if`需要在case列表代码尾部插入多条比较语句，而栈机又需要每次比较前都push相应的参数，实现比较繁琐而且性能较差，因此OCPack在指令集中增加了`cmp_n`、`resolve_label`和`jmp_tos`指令。
* 首先，OCPack编译器在生成指令时会先将switch要比较的目标push进操作栈，然后再将各个case的值push进栈，然后添加`cmp_n n`指令。在运行时，`cmp_n n`指令会从栈上pop出`n`个数据，与栈顶的数据（即switch的目标）进行比较，如果与第`i`个相等，则将`i`push到栈顶。  
* 后面再添加指令`resolve_label label_prefix`。此指令在运行时会将label_prefix与栈顶的`i`进行字符串拼接，生成目标label名，并在machine中进行查找，找到对应的label地址，push到栈顶。其中label_prefix是每个switch语句唯一的，可以支持switch嵌套。  
* 然后再添加指令`jmp_tos`。此指令在运行时会跳转到栈顶的地址，从而实现switch的功能。  

###### 2) continue和break的支持：  
分别维护一个break和continue的label栈，栈顶元素为当前break或continue调用时应该jmp到的目标label，在目标表达式开始和结束时进行入栈和出栈操作。在遇到语法树上结点为break或continue时，取出当前栈顶的目标label，生成`jmp 目标label`指令。 

##### 2.6 call指令
* 使用libffi实现动态c方法调用。对于每个被调用的c方法，在.s会有一项DECL_C_FUNC的声明，声明包含此方法的名称、签名（包括参数个数和类型）等信息。  
* .s中的参数类型是OCPack自定义的字符串，一一对应到libffi的类型。对于struct来说，生成指令时需要递归找到struct所有成员的类型，拼成相应的字符串，然后在运行期反解字符串，构造出libffi所需的数据类型。  
* 对于变参的方法，方法名相同而参数个数或类型不同的，在DECL_C_FUNC时会对应不同的条目，虚拟机在运行时会根据对应的条目去构造相应的libffi参数数据。

##### 2.7 基本一元、二元运算符指令
* 指令集中对算术、逻辑、移位等等基本运算符都有对应的指令，指令参数包括返回值类型、操作数类型等。  
* 在虚拟机的实现代码中将各种运算、数据类型的组合分配到相应的c语言实现，运行时就根据传入的指令和参数调用其相应实现。  

**注：** 此指令只支持整型、浮点型等基本数据类型的运算，不支持自定义类型重载的运算符

##### 2.8 左右值转换
* 指令集有左值转右值的指令，其参数为右值的size。此指令的作用为：先pop操作栈顶存储的地址(addr)，然后取地址为addr的大小为size的内存数据，push到操作栈顶。  
* 在clang生成的AST中，所有VarDeclRef其实对应的是变量的地址，对于访问变量内容（变量右值）的代码，AST中VarDeclRef的父节点都是左右值转换节点。因此OCPack中push指令，类似`push seg index`都是将seg段index处的地址push进操作栈，而取对应地址处的具体内容由左右值转换指令来完成。

**注：** 在实现初期，OCPack的push指令是直接将seg段index处变量的右值push进操作栈（即这种情况下忽略左右值转换的结点），但后来发现在类似赋值操作中的左值变量的情况下，AST中没有左右值转换结点，如果对这些情况特殊处理，逻辑会变得较为复杂且难以保证覆盖完全，后来决定完全依照AST中结点的排布逻辑，将push操作的对象改成了对应变量的左值，牺牲部分性能换取程序的可靠性。

##### 2.9 OC方法调用指令
* 指令集中有专用于调用OC方法的指令OBJC_MSG_CLASS/OBJC_MSG_INST。  
* 虚拟机在解释执行此指令时，先取得存储在栈上的所有参数，然后构造相应的NSInvocation，通过invoke来实现对Objective-C runtime的调用。
* 指令实现中，对于target和参数都采用__unsafe_unretained方式进行引用，即不改变其生命周期。返回值则一律使用autorelease方式，确保返回值在返回给直接调用者时是有效的。

**注：** 实现过程中，OC调用指令所需的输入数据的内存排布顺序也经历了一番修改。因为对于Objective-C方法来说，只有拿到selector才能知道具体有多少个参数，所以之前设计是参数表倒着放，即第一个参数放栈顶，第二个参数依次往下排。这样可以稳定地pop两次就得到selector的声明，然后再根据selector中指明的参数个数及大小pop所有的参数。但这种方法在参数大小大于64bit的情况下（如struct）就比较难处理了，因为要得到正确的struct数据，程序需要pop对应个数的64bit，然后做拼接，烦琐而且容易出错。经权衡，还是在指令参数中增加了参数表长度（编译期得到），在调用OBJC_MSG_CLASS/OBJC_MSG_INST指令前，参数还是按顺序push（即第一个参数先push，栈顶是最后一个参数），在指令的实现中，根据指令参数中提供的参数表长度，直接从sp算出第一个参数的起始位置，这样所有的参数都可以用指针访问，而不用关心其大小了。原先需要的多次pop指令，变成只需在指令退出前，将sp回退参数表长度即可。

### Assembler：汇编程序(.s) -> 二进制程序(.bin)
解析整个.s文本，将文本token转换为对应的二进制数据，主要包括：
* 立即数从文本到二进制数据的转换
* 跳转label到地址的转换
* 常量字符串的转换，此处一开始直接在.s中存储了字符串，后来遇到'\n\t'等情况不能很好地支持，就改成了直接存储字节码
* 生成导出函数表，表中记录了虚拟机中定义的方法名和地址的对应关系
* 生成导入函数表，包含了所有调用到的c方法声明及其index，代码段中调用c方法时直接调用此处的index
* static数据段大小和全局区的总大小，因为虚拟机初始化时需要将全局区放到一段shared & anonymous mmap内存上，故需要此size
* 存储GUID值
* 存储Target arch，此值用于验证32bit和64bit，确保平台和.bin文件的匹配
* 文本指令转化为二进制指令

转换完成后将各数据存入内存中相应的数据段，再将整个内存dump成一个二进制文件。

**注：** 二进程文件在运行时所需的大部分数据其排布都与.bin文件里的排布完全相同，这样能方便地使用内存映射来实现.bin文件的加载，从而可以减少私有内存的占用量。

### Loader：二进制程序(.bin)加载
在调用load_image时，machine会先将.bin文件mmap到一段内存中，检测magic number, bin version及arch是否匹配。
按全局区的大小申请一段shared anonymous mmap内存
分别加载各个数据段，建立必要的运行时内存数据，主要的数据段包括：
* 常量字符串段，将全局区对应大小的内存分配给常量段，并将对应的index指向对应的字符串起始地址
* 静态数据段，将全局区对应大小的内存分配给静态段
* 导出符号表
* 导入符号表
* 代码段
* GUID数据
![bin文件格式](/pics/ocpack_bin_format.png)


### Executor：二进制程序(.bin)执行

#### 1) 虚拟机基本信息
* 栈和各个段都以64bit为单位  
* 调用方法前，需要将对应的参数push到操作栈上  
* 调用完成后，栈顶放的就是返回值
* 运行时上下文(thread_context)和栈帧
    * thread_context维护一个栈帧的链表，用以存放调用关系
    * 栈帧用于存放当前方法的运行时信息，主要包括：
        * 栈帧基地址
        * 返回地址
        * 指向调用方栈帧基地址的指针
        * 段表基地址
        * 操作栈基址
        * 操作栈指针sp
        * 程序计数器ip  
    ![vm函数frame内存布局](/pics/ocpack_frame_layout.png)

#### 2) OC调用虚拟机方法
* Objective-C代码通过向machine的callVMFunctionWithArgs方法传入要调用函数名及其参数（此处的参数为真正参数的地址）并得到返回值来与虚拟机进行交互。  
* callVMFunctionWithArgs方法内部会通过函数名查找导出表，找到其方法签名和地址。然后根据方法签名中指定的参数大小，将传入的参数地址处对应大小的数据push到操作栈上，然后再跳转到被调方法的开始地址处，开始执行汇编指令。  
* 虚拟机执行完所有汇编指令后返回到callVMFunctionWithArgs中，该方法再负责把栈顶的返回值数据拷贝到调用方传入的返回值地址处。
* 调用完成后，虚拟机的栈顶地址应该保持与调用前完全一致。
* 如果虚拟机方法的返回值是NSObject*类型，OCPack会根据存储返回值的变量是否是强引用而决定是否需要对返回的对象做__brige_retained操作，用以中和调用方对strong类型变量的release操作。其他情况下因为返回的都是autorelease的对象，返回时不做特殊处理（详见Compiler节中2.9段`OC方法调用指令`）。

#### 3) 虚拟机调用OC方法(f1)，f1又调用到了虚拟机的方法(f2)
要支持此流程，需保证f2调用完成后虚拟机当前栈帧的sp与调用前完全一致，以保证f1的执行不受影响。

#### 4) 虚拟机方法间互相调用
在调用OC方法时，会先检测对应的方法是否在导出函数表中，如果在，则走此流程。这也要求调用虚拟机方法时的参数表应该与直接调用OC方法是一致的，否则还需要重新拷贝参数做适配，降低虚拟机性能。

#### 5) 多线程支持
* 运行时上下文(thread_context)指针放在线程局部存储中，每个线程在读、写上下文中数据时都是操作当前线程自己的数据，这样就能保证各个线程之间运行状态相互隔离，从而支持多线程的调用场景。  
* OCPack注册了线程退出的回调函数，当一个线程退出时OCPack会删除所有machine在此线程中的上下文相关数据。

#### 6) 内存占用
* 二进制文件加载使用mmap，全局数据区使用shared & anonymous mmap，常量字符串数据直接指向.bin中的地址。  
* 运行时上下文(thread_context)是每个线程一份，都使用shared & anonymous mmap。  
* 运行时的machine只维护导入函数和导出函数数据以及少量指针数据。

#### 7) 崩溃时的栈回溯
* 运行时上下文(thread_context)中维护有一个栈帧结构（thread_frame）的链表，对应的就是虚拟机中方法的调用关系。  
* 崩溃时遍历所有线程中所有虚拟机的thread_context，遍历其栈帧结构链表，取出每个栈帧中存储的ip地址写到崩溃日志中。 
* 崩溃日志中按照线程组织崩溃栈，还会记录每个machine的地址和其加载的.bin文件的GUID，用以正确区分线程、machine的实例和bin文件。  

#### 8) 崩溃符号解析
由OCPack编译器生成或指定一个GUID，后续生成的所有相关文件（包括.s、.sym、.bin以及运行时生成的崩溃log）中都存有此GUID。线上的崩溃log发送回来后，崩溃解析服务器能够根据log中的GUID查找到相应的符号文件进行符号解析。同时build服务器中存储了对应GUID的bin文件打包时所有依赖项的源信息（包括对应的.s文件、bin代码对应的源代码版本、OCPack工具链的版本等），方便开发重现、定位相关问题。

#### 9) Hook Objective-C方法
* 原理与JSPatch类似，通过将目标类的目标方法替换为objc_msgForward，同时将forwardInvocation替换为自定义的forward方法，实现当目标方法被调用时，转向forwardInvocation的自定义实现。在自定义的forward的实现中，将NSInvocation传给内置的machine，machine会取出其参数并调用相应的虚拟机方法，最后将返回值设回给NSInvocation，即完成了Hook的功能。  
* 与JSPatch相比，用OCPack的方法调用省去了大量的字符串解析操作，参数大都可直接传入虚拟机进行处理，方法调用的整体开销比JSPatch小。

### 性能优化
1. 二进制程序的大小优化
    * OCPack在实现初期，采用了模板类的方式实现一、二元操作符的对不同操作数和返回值类型的支持，这样调试起来比较方便。但后来发现这种方案会导致代码体积会暴增。模板方法会根据输入、输出参数的类型生成大量的方法，而其中大部分方法都只有很短的几条指令，从最后的二进制内容分析看，光方法名就占用了大量内存。
    * 在功能基本稳定后，在UT的保证下，将模板改为了宏实现，大幅地减小代码段和数据段的体积，framework文件的大小从3.5M减到了不到150k。
2. 性能优化  
    * 汇编代码优化
        * 由语法树直接生成的汇编代码里面会有很多无用的push操作，主要原因是某些表达式的返回值没有被用到，此时push是多余的，而且在比较大的循环还可能会使栈长度暴增，影响性能和稳定性
        * 优化方法是尽量去掉无用的push指令。主要是通过定义一些规则来判别某指令的返回值是否被用到，对于无用的表达式返回值不进行push操作。
    * 虚拟机性能优化
        * 将频繁用到的数据缓存下来：取运行时上下文和读写栈帧是频繁操作，涉及线程局部存储数据的读取，运行时上下文结构的指针只会在一个线程中访问，通过对代码进行重构，将它缓存到executor类中，提高了运行时效率。
        * 尽量减少核心循环处代码的内存访问次数：将栈帧中的部分数据（如：ip）提出来放到executor类中，减少频繁读写ip时导致的不必要的内存操作次数。
        * 尽量提高核心循环处代码效率：用数组代替map实现指令到指令处理器的映射关系，提高运行时查询效率。
        * 优化后比优化前提高了将近一倍

## III. 未来计划

### Linker
支持多个.m及多个.bin链接成一个.bin，而且.bin之间互相调用  

### 其他语法支持
#### 1) Block
支持block

#### 2) 性能优化
* 去掉虚函数调用
* 指令长度对齐
* 保证sp、ip等频繁操作的数据都放入寄存器——汇编实现相关核心方法、或者改变代码结构
* 生成汇编代码的优化

### Debug工具
因为虚拟机执行时是按指令执行的，不容易直接对应到Objective-C代码，调试起来有点麻烦，后续计划做一些功能，调试时方便地显示指令地址到Objective-C源代码的对应关系。
